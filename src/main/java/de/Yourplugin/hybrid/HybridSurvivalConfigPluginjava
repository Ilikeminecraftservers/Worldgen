package de.yourplugin.hybrid;

import com.sk89q.worldedit.*;
import com.sk89q.worldedit.bukkit.BukkitAdapter;
import com.sk89q.worldedit.extent.clipboard.*;
import com.sk89q.worldedit.extent.clipboard.io.*;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.Sign;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.*;
import org.bukkit.event.block.Action;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import java.util.concurrent.*;

public class HybridSurvivalConfigPlugin extends JavaPlugin implements Listener {

    // ==================== Config Flags ====================
    private boolean progressiveDetail, chunkPreload, lazyLight, rpcThreading, pasteThreading;
    private boolean generateBuildings, buildingPurchase, signPurchase, osmInteriors, shopSystem, synchronizeHeight;
    private boolean teleportToBuilding, commandPurchase, buildingSell, guiBuildingList;
    private boolean asyncEvents, telemetry, chunkCacheEnabled, prefetchSpawn;

    private int maxChunksPerTick, lightsPerTick, preloadRadius;

    private final ChunkCache chunkCache = new ChunkCache();
    private final Queue<ChunkPosition> lightQueue = new ConcurrentLinkedQueue<>();
    private ExecutorService rpcPool;
    private ExecutorService pastePool;
    private final Map<String, BuildingData> buildings = new ConcurrentHashMap<>();

    @Override
    public void onEnable() {
        saveDefaultConfig();

        // Config laden
        progressiveDetail = getConfig().getBoolean("progressive-detail", true);
        chunkPreload = getConfig().getBoolean("chunk-preload", true);
        lazyLight = getConfig().getBoolean("lazy-light", true);
        rpcThreading = getConfig().getBoolean("rpc-threading", true);
        pasteThreading = getConfig().getBoolean("paste-threading", true);

        generateBuildings = getConfig().getBoolean("generate-buildings", true);
        buildingPurchase = getConfig().getBoolean("building-purchase", true);
        signPurchase = getConfig().getBoolean("sign-purchase", true);
        osmInteriors = getConfig().getBoolean("osm-interiors", false);
        shopSystem = getConfig().getBoolean("shop-system", false);
        synchronizeHeight = getConfig().getBoolean("synchronize-height", true);
        teleportToBuilding = getConfig().getBoolean("teleport-to-building", true);
        commandPurchase = getConfig().getBoolean("command-purchase", true);
        buildingSell = getConfig().getBoolean("building-sell", true);
        guiBuildingList = getConfig().getBoolean("gui-building-list", true);

        maxChunksPerTick = getConfig().getInt("max-chunks-per-tick", 16);
        lightsPerTick = getConfig().getInt("lights-per-tick", 2);
        preloadRadius = getConfig().getInt("preload-radius", 16);
        asyncEvents = getConfig().getBoolean("async-events", true);
        telemetry = getConfig().getBoolean("telemetry", true);
        chunkCacheEnabled = getConfig().getBoolean("chunk-cache", true);
        prefetchSpawn = getConfig().getBoolean("prefetch-spawn", true);

        // Thread-Pools
        if(rpcThreading) rpcPool = Executors.newFixedThreadPool(8);
        if(pasteThreading) pastePool = Executors.newFixedThreadPool(4);

        // Listener
        Bukkit.getPluginManager().registerEvents(this, this);
        if(lazyLight) Bukkit.getScheduler().runTaskTimer(this, this::processLazyLight,1L,1L);
    }

    @Override
    public void onDisable() {
        if(rpcPool!=null) rpcPool.shutdown();
        if(pastePool!=null) pastePool.shutdown();
    }

    // ==================== Player Move → Chunk Load ====================
    @EventHandler
    public void onPlayerMove(PlayerMoveEvent event){
        if(!chunkPreload) return;

        Player player = event.getPlayer();
        int cx = player.getLocation().getChunk().getX();
        int cz = player.getLocation().getChunk().getZ();

        byte[] cached = chunkCache.get(cx, cz);
        if(cached!=null) pasteDelta(cx, cz, cached, player.getWorld());

        List<int[]> chunks = getChunksByPriority(player, cx, cz);
        List<int[]> batch = new ArrayList<>();
        for(int[] chunk : chunks){
            if(!chunkCache.contains(chunk[0], chunk[1])) batch.add(chunk);
            if(batch.size()>=maxChunksPerTick){ submitChunkBatch(batch, player); batch.clear(); }
        }
        if(!batch.isEmpty()) submitChunkBatch(batch, player);
    }

    private void submitChunkBatch(List<int[]> batch, Player player){
        Runnable task = () -> {
            for(int[] chunk: batch){
                int cx=chunk[0], cz=chunk[1];
                if(!chunkCache.contains(cx, cz)){
                    try{
                        int[][] terraHeight = fetchTerraHeight(cx, cz);
                        byte[] arnisData;
                        if(progressiveDetail){
                            arnisData = fetchArnisChunk(cx, cz, terraHeight, 1);
                            if(chunkCacheEnabled) chunkCache.put(cx, cz, arnisData);
                            pasteDelta(cx, cz, arnisData, player.getWorld());
                            if(rpcThreading){
                                rpcPool.submit(()->{
                                    try{
                                        byte[] details = fetchArnisChunk(cx, cz, terraHeight, 2);
                                        if(chunkCacheEnabled) chunkCache.put(cx, cz, details);
                                        pasteDelta(cx, cz, details, player.getWorld());
                                    }catch(Exception e){e.printStackTrace();}
                                });
                            }
                        } else{
                            arnisData = fetchArnisChunk(cx, cz, terraHeight, 0);
                            if(chunkCacheEnabled) chunkCache.put(cx, cz, arnisData);
                            pasteDelta(cx, cz, arnisData, player.getWorld());
                        }
                        if(generateBuildings) generateBuilding(cx, cz, player.getWorld());
                    }catch(Exception e){e.printStackTrace();}
                }
            }
        };
        if(rpcThreading) rpcPool.submit(task); else task.run();
    }

    private int[][] fetchTerraHeight(int cx,int cz){
        int[][] heightMap=new int[16][16];
        for(int x=0;x<16;x++) for(int z=0;z<16;z++) heightMap[x][z]=64;
        return heightMap;
    }

    private byte[] fetchArnisChunk(int cx,int cz,int[][] terraHeight,int phase) throws IOException{
        URL url=new URL("http://127.0.0.1:3000/generate");
        HttpURLConnection conn=(HttpURLConnection)url.openConnection();
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
        conn.setRequestProperty("Content-Type","application/json");
        String json=String.format("{\"chunkX\":%d,\"chunkZ\":%d,\"chunkSize\":16,\"heightMap\":%s,\"phase\":%d}",cx,cz,Arrays.deepToString(terraHeight),phase);
        conn.getOutputStream().write(json.getBytes());
        if(conn.getResponseCode()==200) return conn.getInputStream().readAllBytes();
        return null;
    }

    private void pasteDelta(int cx,int cz,byte[] data, World world){
        Runnable task = ()->{
            try{
                ClipboardFormat format=ClipboardFormats.findByFile(new ByteArrayInputStream(data));
                if(format==null) return;
                try(ClipboardReader reader=format.getReader(new ByteArrayInputStream(data))){
                    com.sk89q.worldedit.extent.clipboard.Clipboard clipboard=reader.read();
                    ClipboardHolder holder=new ClipboardHolder(clipboard);
                    EditSession editSession=WorldEdit.getInstance().newEditSession(BukkitAdapter.adapt(world));
                    int xPos=cx*16, zPos=cz*16;
                    holder.createPaste(editSession).to(com.sk89q.worldedit.math.BlockVector3.at(xPos,0,zPos))
                            .ignoreAirBlocks(false).build().paste();
                    editSession.flushQueue();
                }
                if(lazyLight) queueLazyLight(cx, cz, world);
            }catch(Exception e){ e.printStackTrace(); }
        };
        if(pasteThreading) pastePool.submit(task); else task.run();
    }

    private void queueLazyLight(int cx,int cz, World world){ lightQueue.add(new ChunkPosition(cx, cz, world)); }
    private void processLazyLight(){
        if(!lazyLight) return;
        for(int i=0;i<lightsPerTick;i++){
            ChunkPosition pos = lightQueue.poll();
            if(pos==null) break;
            pos.world.refreshChunk(pos.chunkX,pos.chunkZ);
        }
    }

    private List<int[]> getChunksByPriority(Player player,int cx,int cz){
        List<int[]> chunks=new ArrayList<>();
        for(int dx=-preloadRadius;dx<preloadRadius;dx++)
            for(int dz=-preloadRadius;dz<preloadRadius;dz++)
                chunks.add(new int[]{cx+dx,cz+dz});
        return chunks;
    }

    // ==================== Gebäude ====================
    private void generateBuilding(int cx,int cz, World world){
        if(!generateBuildings) return;
        Location buildingLoc = new Location(world, cx*16+8, 64, cz*16+8);
        String street = "Street"+cx+"_"+cz;
        int number = new Random().nextInt(100)+1;
        BuildingData b = new BuildingData(buildingLoc, street, number);
        buildings.put(b.getAddress(), b);
        if(signPurchase) placeAddressSign(b, world);
    }

    private void placeAddressSign(BuildingData b, World world){
        Location signLoc = b.getLocation().clone().add(0,1,1);
        world.getBlockAt(signLoc).setType(Material.OAK_SIGN);
        Sign sign = (Sign) world.getBlockAt(signLoc).getState();
        sign.setLine(0, "Adresse:");
        sign.setLine(1, b.getAddress());
        sign.setLine(2, "Zu verkaufen");
        sign.update();
    }

    @EventHandler
    public void onSignClick(PlayerInteractEvent e){
        if(!signPurchase) return;
        if(e.getAction() != Action.RIGHT_CLICK_BLOCK) return;
        Block block = e.getClickedBlock();
        if(block.getType() != Material.OAK_SIGN) return;
        Sign sign = (Sign) block.getState();
        String line1 = sign.getLine(1);
        BuildingData building = buildings.get(line1);
        if(building == null || building.isPurchased()) return;
        building.setOwner(e.getPlayer().getUniqueId());
        sign.setLine(2, "Besitzer:");
        sign.setLine(3, e.getPlayer().getName());
        sign.update();
    }
}
