package de.yourplugin.hybrid;

import com.sk89q.worldedit.*;
import com.sk89q.worldedit.bukkit.BukkitAdapter;
import com.sk89q.worldedit.extent.clipboard.*;
import com.sk89q.worldedit.extent.clipboard.io.*;
import com.sk89q.worldedit.session.ClipboardHolder;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.Sign;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.*;
import org.bukkit.event.block.Action;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import java.util.concurrent.*;

public class HybridSurvivalConfigPlugin extends JavaPlugin implements Listener {

    // ==================== Config Flags ====================
    private boolean progressiveDetail, chunkPreload, lazyLight, rpcThreading, pasteThreading;
    private boolean generateBuildings, buildingPurchase, signPurchase, osmInteriors, shopSystem, synchronizeHeight;
    private boolean teleportToBuilding, commandPurchase, buildingSell, guiBuildingList;
    private boolean asyncEvents, telemetry, chunkCacheEnabled, prefetchSpawn;

    private boolean streetsEnabled, sidewalksEnabled, parkingsEnabled;
    private boolean decoLampsEnabled, decoTreesEnabled, decoBenchesEnabled;

    private int maxChunksPerTick, lightsPerTick, preloadRadius;
    private String arnisPath;
    private int bboxRadius;
    private Material streetBlock, lineBlock, sidewalkBlock, parkingBlock, parkingLineBlock;

    private final ChunkCache chunkCache = new ChunkCache();
    private final Queue<ChunkPosition> lightQueue = new ConcurrentLinkedQueue<>();
    private ExecutorService rpcPool;
    private ExecutorService pastePool;
    private final Map<String, BuildingData> buildings = new ConcurrentHashMap<>();

    private StreetGenerator streetGen;
    private DecorationManager decoMgr;

    @Override
    public void onEnable() {
        saveDefaultConfig();
        FileConfiguration cfg = getConfig();

        // Kern-Features
        progressiveDetail = cfg.getBoolean("progressive-detail", true);
        chunkPreload = cfg.getBoolean("chunk-preload", true);
        lazyLight = cfg.getBoolean("lazy-light", true);
        rpcThreading = cfg.getBoolean("rpc-threading", true);
        pasteThreading = cfg.getBoolean("paste-threading", true);

        // Gebäude & Immobilien
        generateBuildings = cfg.getBoolean("generate-buildings", true);
        buildingPurchase = cfg.getBoolean("building-purchase", true);
        signPurchase = cfg.getBoolean("sign-purchase", true);
        osmInteriors = cfg.getBoolean("osm-interiors", false);
        shopSystem = cfg.getBoolean("shop-system", false);
        synchronizeHeight = cfg.getBoolean("synchronize-height", true);
        teleportToBuilding = cfg.getBoolean("teleport-to-building", true);
        commandPurchase = cfg.getBoolean("command-purchase", true);
        buildingSell = cfg.getBoolean("building-sell", true);
        guiBuildingList = cfg.getBoolean("gui-building-list", true);

        // Performance
        maxChunksPerTick = cfg.getInt("max-chunks-per-tick", 16);
        lightsPerTick = cfg.getInt("lights-per-tick", 2);
        preloadRadius = cfg.getInt("preload-radius", 16);
        asyncEvents = cfg.getBoolean("async-events", true);
        telemetry = cfg.getBoolean("telemetry", true);
        chunkCacheEnabled = cfg.getBoolean("chunk-cache", true);
        prefetchSpawn = cfg.getBoolean("prefetch-spawn", true);

        // Arnis-Integration
        arnisPath = cfg.getString("arnis.path", "/usr/local/bin/arnis");
        bboxRadius = cfg.getInt("arnis.bbox-radius-meters", 100);

        // Straßen & Parkplätze
        streetsEnabled = cfg.getBoolean("streets.enabled", true);
        streetBlock = Material.matchMaterial(cfg.getString("streets.block", "BLUE_ICE"));
        lineBlock = Material.matchMaterial(cfg.getString("streets.line-block", "ICE"));
        sidewalksEnabled = cfg.getBoolean("streets.sidewalks.enabled", false);
        sidewalkBlock = Material.matchMaterial(cfg.getString("streets.sidewalks.block", "STONE_BRICKS"));

        parkingsEnabled = cfg.getBoolean("parkings.enabled", true);
        parkingBlock = Material.matchMaterial(cfg.getString("parkings.block", "PACKED_ICE"));
        parkingLineBlock = Material.matchMaterial(cfg.getString("parkings.line-block", "ICE"));

        // Dekorationen
        decoLampsEnabled = cfg.getBoolean("decorations.street-lamps.enabled", false);
        decoTreesEnabled = cfg.getBoolean("decorations.trees.enabled", false);
        decoBenchesEnabled = cfg.getBoolean("decorations.benches.enabled", false);

        // Extra-Manager
        streetGen = new StreetGenerator(cfg);
        decoMgr = new DecorationManager(cfg);

        // Thread-Pools
        if (rpcThreading) rpcPool = Executors.newFixedThreadPool(8);
        if (pasteThreading) pastePool = Executors.newFixedThreadPool(4);

        // Listener
        Bukkit.getPluginManager().registerEvents(this, this);
        if (lazyLight) Bukkit.getScheduler().runTaskTimer(this, this::processLazyLight, 1L, 1L);

        getLogger().info("HybridSurvivalConfigPlugin enabled with Arnis at: " + arnisPath);
    }

    @Override
    public void onDisable() {
        if (rpcPool != null) rpcPool.shutdown();
        if (pastePool != null) pastePool.shutdown();
    }

    // ==================== Player Move → Chunk Load ====================
    @EventHandler
    public void onPlayerMove(PlayerMoveEvent event) {
        if (!chunkPreload) return;

        Player player = event.getPlayer();
        int cx = player.getLocation().getChunk().getX();
        int cz = player.getLocation().getChunk().getZ();

        byte[] cached = chunkCache.get(cx, cz);
        if (cached != null) pasteDelta(cx, cz, cached, player.getWorld());

        List<int[]> chunks = getChunksByPriority(player, cx, cz);
        List<int[]> batch = new ArrayList<>();
        for (int[] chunk : chunks) {
            if (!chunkCache.contains(chunk[0], chunk[1])) batch.add(chunk);
            if (batch.size() >= maxChunksPerTick) {
                submitChunkBatch(batch, player);
                batch.clear();
            }
        }
        if (!batch.isEmpty()) submitChunkBatch(batch, player);
    }

    private void submitChunkBatch(List<int[]> batch, Player player) {
        Runnable task = () -> {
            for (int[] chunk : batch) {
                int cx = chunk[0], cz = chunk[1];
                if (!chunkCache.contains(cx, cz)) {
                    try {
                        int[][] terraHeight = fetchTerraHeight(cx, cz);
                        byte[] arnisData;
                        if (progressiveDetail) {
                            arnisData = fetchArnisChunk(cx, cz, terraHeight, 1);
                            if (chunkCacheEnabled) chunkCache.put(cx, cz, arnisData);
                            pasteDelta(cx, cz, arnisData, player.getWorld());
                            if (rpcThreading) {
                                rpcPool.submit(() -> {
                                    try {
                                        byte[] details = fetchArnisChunk(cx, cz, terraHeight, 2);
                                        if (chunkCacheEnabled) chunkCache.put(cx, cz, details);
                                        pasteDelta(cx, cz, details, player.getWorld());
                                    } catch (Exception e) { e.printStackTrace(); }
                                });
                            }
                        } else {
                            arnisData = fetchArnisChunk(cx, cz, terraHeight, 0);
                            if (chunkCacheEnabled) chunkCache.put(cx, cz, arnisData);
                            pasteDelta(cx, cz, arnisData, player.getWorld());
                        }

                        if (generateBuildings) generateBuilding(cx, cz, player.getWorld());
                        if (streetsEnabled)
                            streetGen.generateStreet(player.getWorld(), new Location(player.getWorld(), cx * 16, 64, cz * 16));
                        if (parkingsEnabled)
                            streetGen.generateParking(player.getWorld(), new Location(player.getWorld(), cx * 16 + 8, 64, cz * 16 + 8));
                        if (decoLampsEnabled)
                            decoMgr.placeLamp(player.getWorld(), new Location(player.getWorld(), cx * 16 + 4, 65, cz * 16 + 4));

                    } catch (Exception e) { e.printStackTrace(); }
                }
            }
        };
        if (rpcThreading) rpcPool.submit(task); else task.run();
    }

    // Dummy height fetch
    private int[][] fetchTerraHeight(int cx, int cz) {
        int[][] heightMap = new int[16][16];
        for (int x = 0; x < 16; x++)
            for (int z = 0; z < 16; z++)
                heightMap[x][z] = 64;
        return heightMap;
    }

    // Arnis HTTP call
    private byte[] fetchArnisChunk(int cx, int cz, int[][] terraHeight, int phase) throws IOException {
        URL url = new URL("http://127.0.0.1:3000/generate");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setDoOutput(true);
        conn.setRequestProperty("Content-Type", "application/json");
        String json = String.format(
                "{\"chunkX\":%d,\"chunkZ\":%d,\"chunkSize\":16,\"heightMap\":%s,\"phase\":%d,\"bboxRadius\":%d,\"arnisPath\":\"%s\"}",
                cx, cz, Arrays.deepToString(terraHeight), phase, bboxRadius, arnisPath
        );
        conn.getOutputStream().write(json.getBytes());
        if (conn.getResponseCode() == 200) return conn.getInputStream().readAllBytes();
        return null;
    }

    // Paste schematic into world
    private void pasteDelta(int cx, int cz, byte[] data, World world) {
        Runnable task = () -> {
            try {
                ClipboardFormat format = ClipboardFormats.findByFile(new ByteArrayInputStream(data));
                if (format == null) return;
                try (ClipboardReader reader = format.getReader(new ByteArrayInputStream(data))) {
                    com.sk89q.worldedit.extent.clipboard.Clipboard clipboard = reader.read();
                    ClipboardHolder holder = new ClipboardHolder(clipboard);
                    try (EditSession editSession = WorldEdit.getInstance().newEditSession(BukkitAdapter.adapt(world))) {
                        int xPos = cx * 16, zPos = cz * 16;
                        holder.createPaste(editSession)
                                .to(com.sk89q.worldedit.math.BlockVector3.at(xPos, 0, zPos))
                                .ignoreAirBlocks(false).build().paste();
                        editSession.flushQueue();
                    }
                }
                if (lazyLight) queueLazyLight(cx, cz, world);
            } catch (Exception e) { e.printStackTrace(); }
        };
        if (pasteThreading) pastePool.submit(task); else task.run();
    }

    private void queueLazyLight(int cx, int cz, World world) { lightQueue.add(new ChunkPosition(cx, cz, world)); }
    private void processLazyLight() {
        if (!lazyLight) return;
        for (int i = 0; i < lightsPerTick; i++) {
            ChunkPosition pos = lightQueue.poll();
            if (pos == null) break;
            pos.world.refreshChunk(pos.chunkX, pos.chunkZ);
        }
    }

    private List<int[]> getChunksByPriority(Player player, int cx, int cz) {
        List<int[]> chunks = new ArrayList<>();
        for (int dx = -preloadRadius; dx < preloadRadius; dx++)
            for (int dz = -preloadRadius; dz < preloadRadius; dz++)
                chunks.add(new int[]{cx + dx, cz + dz});
        return chunks;
    }

    // ==================== Gebäude ====================
    private void generateBuilding(int cx, int cz, World world) {
        if (!generateBuildings) return;
        Location buildingLoc = new Location(world, cx * 16 + 8, 64, cz * 16 + 8);
        String street = "Street" + cx + "_" + cz;
        int number = new Random().nextInt(100) + 1;
        BuildingData b = new BuildingData(buildingLoc, street, number);
        buildings.put(b.getAddress(), b);
        if (signPurchase) placeAddressSign(b, world);
    }

    private void placeAddressSign(BuildingData b, World world) {
        Location signLoc = b.getLocation().clone().add(0, 1, 1);
        world.getBlockAt(signLoc).setType(Material.OAK_SIGN);
        Sign sign = (Sign) world.getBlockAt(signLoc).getState();
        sign.setLine(0, "Adresse:");
        sign.setLine(1, b.getAddress());
        sign.setLine(2, "Zu verkaufen");
        sign.update();
    }

    @EventHandler
    public void onSignClick(PlayerInteractEvent e) {
        if (!signPurchase) return;
        if (e.getAction() != Action.RIGHT_CLICK_BLOCK) return;
        Block block = e.getClickedBlock();
        if (block == null || block.getType() != Material.OAK_SIGN) return;
        Sign sign = (Sign) block.getState();
        String line1 = sign.getLine(1);
        BuildingData building = buildings.get(line1);
        if (building == null || building.isPurchased()) return;
        building.setOwner(e.getPlayer().getUniqueId());
        sign.setLine(2, "Besitzer:");
        sign.setLine(3, e.getPlayer().getName());
        sign.update();
    }
}